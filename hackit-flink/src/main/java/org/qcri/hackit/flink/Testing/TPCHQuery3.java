package org.qcri.hackit.flink.Testing;


import org.apache.flink.api.common.functions.FilterFunction;
import org.apache.flink.api.common.functions.JoinFunction;
import org.apache.flink.api.java.DataSet;
import org.apache.flink.api.java.ExecutionEnvironment;
import org.apache.flink.api.java.aggregation.Aggregations;
import org.apache.flink.api.java.utils.ParameterTool;
import org.apache.flink.core.fs.FileSystem;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.text.ParseException;


/**
 * This program implements a modified version of the TPC-H query 3. The
 * example demonstrates how to assign names to fields by extending the Tuple class.
 * The original query can be found at
 * <a href="http://www.tpc.org/tpch/spec/tpch2.16.0.pdf">http://www.tpc.org/tpch/spec/tpch2.16.0.pdf</a> (page 29).
 *
 * <p>This program implements the following SQL equivalent:
 *
 * <p><pre>{@code
 * SELECT
 *      l_orderkey,
 *      SUM(l_extendedprice*(1-l_discount)) AS revenue,
 *      o_orderdate,
 *      o_shippriority
 * FROM customer,
 *      orders,
 *      lineitem
 * WHERE
 *      c_mktsegment = '[SEGMENT]'
 *      AND c_custkey = o_custkey
 *      AND l_orderkey = o_orderkey
 *      AND o_orderdate < date '[DATE]'
 *      AND l_shipdate > date '[DATE]'
 * GROUP BY
 *      l_orderkey,
 *      o_orderdate,
 *      o_shippriority;
 * }</pre>
 *
 * <p>Compared to the original TPC-H query this version does not sort the result by revenue
 * and orderdate.
 *
 * <p>Input files are plain text CSV files using the pipe character ('|') as field separator
 * as generated by the TPC-H data generator which is available at <a href="http://www.tpc.org/tpch/">http://www.tpc.org/tpch/</a>.
 *
 * <p>Usage: <code>TPCHQuery3 --lineitem&lt;path&gt; --customer &lt;path&gt; --orders&lt;path&gt; --output &lt;path&gt;</code><br>
 *
 * <p>This example shows how to use:
 * <ul>
 * <li> custom data type derived from tuple data types
 * <li> inline-defined functions
 * <li> build-in aggregation functions
 * </ul>
 */
public class TPCHQuery3 {

    public static void runTPCHQ3(String[] args, ExecutionEnvironment env, ParameterTool params, int iteration) throws ParseException {

        final String outputPath = "/Users/joschavonhein/Workspace/bdapro-ss20-dataprov/hackit-src/hackit-flink/Output/tpch";

        // get input data
        DataSet<HelperClasses.Lineitem> lineitems = HelperClasses.getLineitemDataSet(env, params.get("lineitem", "/Users/joschavonhein/Data/lineitem.tbl"));
        DataSet<HelperClasses.Customer> customers = HelperClasses.getCustomerDataSet(env, params.get("customer", "/Users/joschavonhein/Data/customer.tbl"));
        DataSet<HelperClasses.Order> orders = HelperClasses.getOrdersDataSet(env, params.get("orders", "/Users/joschavonhein/Data/orders.tbl"));


        // Filter market segment "AUTOMOBILE"
        customers = customers.filter(
                new FilterFunction<HelperClasses.Customer>() {
                    @Override
                    public boolean filter(HelperClasses.Customer c) {
                        return c.getMktsegment().equals("AUTOMOBILE");
                    }
                });

        // Filter all Orders with o_orderdate < 12.03.1995
        orders = orders.filter(
                new FilterFunction<HelperClasses.Order>() {
                    private final DateFormat format = new SimpleDateFormat("yyyy-MM-dd");
                    private final Date date = format.parse("1995-03-12");

                    @Override
                    public boolean filter(HelperClasses.Order o) throws ParseException {
                        return format.parse(o.getOrderdate()).before(date);
                    }
                });

        // Filter all Lineitems with l_shipdate > 12.03.1995
        lineitems = lineitems.filter(
                new FilterFunction<HelperClasses.Lineitem>() {
                    private final DateFormat format = new SimpleDateFormat("yyyy-MM-dd");
                    private final Date date = format.parse("1995-03-12");

                    @Override
                    public boolean filter(HelperClasses.Lineitem l) throws ParseException {
                        return format.parse(l.getShipdate()).after(date);
                    }
                });

        // Join customers with orders and package them into a ShippingPriorityItem
        DataSet<HelperClasses.ShippingPriorityItem> customerWithOrders =
                customers.join(orders).where(0).equalTo(1)
                        .with(
                                new JoinFunction<HelperClasses.Customer, HelperClasses.Order, HelperClasses.ShippingPriorityItem>() {
                                    @Override
                                    public HelperClasses.ShippingPriorityItem join(HelperClasses.Customer c, HelperClasses.Order o) {
                                        return new HelperClasses.ShippingPriorityItem(o.getOrderKey(), 0.0, o.getOrderdate(),
                                                o.getShippriority());
                                    }
                                });

        // Join the last join result with Lineitems
        DataSet<HelperClasses.ShippingPriorityItem> result =
                customerWithOrders.join(lineitems).where(0).equalTo(0)
                        .with(
                                new JoinFunction<HelperClasses.ShippingPriorityItem, HelperClasses.Lineitem, HelperClasses.ShippingPriorityItem>() {
                                    @Override
                                    public HelperClasses.ShippingPriorityItem join(HelperClasses.ShippingPriorityItem i, HelperClasses.Lineitem l) {
                                        i.setRevenue(l.getExtendedprice() * (1 - l.getDiscount()));
                                        return i;
                                    }
                                })
                        // Group by l_orderkey, o_orderdate and o_shippriority and compute revenue sum
                        .groupBy(0, 2, 3)
                        .aggregate(Aggregations.SUM, 1);

        // emit result
        result.writeAsCsv(outputPath+"_"+iteration+".csv", "\n", "|", FileSystem.WriteMode.OVERWRITE).setParallelism(1);

        // execute program
        try {
            env.execute("TPCH Query 3");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
